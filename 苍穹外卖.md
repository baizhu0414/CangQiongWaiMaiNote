

# 基础梳理
 ## Spring基础
**1. 基础概念**
- IoC、DI：控制反转。DI是依赖注入，属于特殊的IoC。在Spring中就是让容器控制对象间的关系。
- 面向接口编程：@Component标注在接口Service的实现类ServiceImpl上，这样容器获取接口能直接获取(AnnotationConfigApplicationContext)或注入(@Autowired)到相应对象Service obj（实际注入ServiceImpl对象）。
  - 多继承类的注入会发生报错,有下面两种解决方法：
    - 1) 使用@Autowired+@Qualifier("首字母小写的子类名称"); 
    - 2) 使用@Value(name="首字母小写的子类名称")。
  

**2. 常见注解**
- @Resource：java中的注入注解，Spring也支持。
- @Value：常量值注入

**3. Spring注解@Autowired的原理**

法1.基于构造方法的方式

法2.基于setter的方式

法3.直接在变量注解，通过反射实现

**4. AOP切面注解编程(集中通知类型)**
> 基于aspectjweaver、spring-aop 这些依赖
> ```java
>@Configuration
>@ComponentScan
>@EnableAspectJAutoProxy // AOP:启用后，Spring 会识别并处理标注了@Aspect的切面类，使得切面中定义的通知（如@Before、@After、@Around等）能够生效，实现对目标方法的增强（如日志记录、事务控制、权限校验等横切逻辑）。
>public class SpringConfig {
>
>    // 定义一个UserService类型的>Bean，Spring容器会管理它的实例
>    @Bean
>    public UserService userService() {
>        return new UserService(); // 返回需要被Spring管理的对象
>    }
>
>    // 定义一个DataSource类型的Bean（例如数据库连接池）
>    @Bean
>    public DataSource dataSource() {
>        DruidDataSource dataSource = new DruidDataSource();
>        dataSource.setUrl("jdbc:mysql://localhost:3306/test");
>        dataSource.setUsername("root");
>        dataSource.setPassword("123456");
>        return dataSource;
>    }
>}
> ```

1. `@Component+@Aspect创建切面`+`@Pointcut定义切入点表达式`；常用表达式类型：bean()、execution()、within()、args()。
    ```java
     // 匹配Spring容器中名称为"demoCls"的Bean的所有方法
     @Pointcut("bean(demoCls)")
     public void pointCutMethod(){}

     // 其他写法
     // 匹配service包下 所有类 public方法
     @Pointcut("execution(pubic * com.example.service.*.*(..))")
     // 匹配userservice中所有get开头的方法
     @Pointcut("execution(* com.example.service.UserService.get*(..))")
     // 匹配所有返回string的无参方法
     @Pointcut("execution(String *())")

     // 还有within、args等关键字
    ```
1. 添加切面的位置
   - @Before("pointCutMethod()") `// 此处复用了前面的切入点@PointCut的名称，而这些在同一个类中。`
   - @After
   - @AfterReturning
   - @AfterThrowing
   - @Around：需要手动调用方法，可以在前后添加内容。
    ```java
    @Before("pointCutMethod()")
    public void checkAuth() {
        // 会在对应类 DemoCls 中的方法前执行权限验证操作
    }
    ```

2. 概念解释
   - 切面：`@Component+@Aspect+@Pointcut+@Before`组成的类和方法就是切面，例如日志切面负责处理日志。
   - 目标对象：@Pointcut匹配到的类
   - 后面调用demoClsObj.fun()前后会执行切面方法，这是基于动态代理实现的。

**5. 事务**
- 配置和使用
    ```java
    // 配置
    @Configuration
    @ComponentScan
    @EnableAspectJAutoProxy
    @EnableTransactionManagement //开启事务管理
    public class SpringConfig {
        // 数据库交互需要，数据源
        @Bean
        public PlatformTransactionManager transactionManager(DataSource dataSource){
            // 数据源通过SSM得到，无法直接从mybatis的配置得到
            return new DataSourceTransactionManager(dataSource);
        }
    }

    // 使用
    @Transactional
    public void method() {
        methodA();
        methodB();
    }
    ```

- @Transactional讲解
  - 注解内部propagation方法
    ```
    required：默认，事务调用其他事务，直接加入当前事务，如果当前事务不存在才新建。
    ```
  - 注解内部isolation方法（多个事务相互间隔离级别）
    ```
    1) read uncommitted：高并发、可以读取未提交数据，导致出现脏读、不可重复读、幻读的风险。
    2) read committed：解决脏读问题。oracle默认级别。
    3) repeatable read： 解决不可重复读问题。mysql默认级别。
    4) serializable：串行化，解决幻读问题。
    ```
- 事务失效
   1) 非public方法
   2) 直接调用注解方法也不会触发事务
   3) 默认事务处理，对于非受检异常（Unchecked Exception）：RuntimeException及其子类才会进行回滚，受检异常如IOException不会回滚。
   4) 动态代理无法代理final、static修饰方法。
   ```java
   @Transactional(
    isolatio = ISolation.READ_COMMITTED, //隔离级别
    propagation =Propagation.REQUIRED, // 传播行为
    timeout = 30, // 超时秒数
    rollbackFor =RuntimeException.class // 回滚异常
   ```


## SpringMVC架构
> 配置pom.xml：略
>

- 配置类
    ```java
    @Configuration
    @ComponentScan("com.example.mvc")
    @EnableWebMvc
    public class SpringMvcConfig implements WebMvcConfigurer {

        @0verride
        public void addResourceHandlers(ResourceHandlerRegistry registry){
            //作用：针对前后端不分离的项目，可配置静态资源放行
            registry
                //表示所有以/static/开头的请求都会被这个处理器处理
                .addResourceHandler("/static/**")
                //classpath:/static/表示这些资源位于类路径下的static目录中
                .addResourceLocations("classpath:/static/")
                // 缓存一年
                .setCacheControl(CacheControl.maxAge(Duration.ofDays(365)));
        }

    }

    public class Servletconfig extends AbstractAnnotationConfigDispatcherServletInitializer {
        // 略
    }
    ```
- 编写Controller类支持不同请求（可能需要额外配置）
    ```java
    @Controller //基于@Component，类似的扫描类：@Indexed、@Service
    // @RestController 表示返回值全部是字符串，替代每次都要@ResponseBody。前后端分离的开发方式常用。
    @RequestMapping("/mvc")
    public class MvcController {
        // 细分路径接口
        @RequestMapping("/index")
        public String index(){
            return"/static/index.html";
        }

        @RequestMapping(path="/test", method=RequestMethod.GET)
        @ResponseBody // 支持字符串类型结果
        public String test(){
            return “提莫”;
        }

        @GetMapping("/url") // 等价于RequestMapping，区分原因是为了方便后处理。此处接收参数是url类型请求的参数。
        @ResponseBody
        public String url(@RequestParam String param1,String param2,String username, Integer age){ // @RequestParam强制不为空
            System.out.println(param1);
            System.out.printn(username);
            System.out.println(age);
            return "teemo";
        }

        @PostMapping("/body") // 此处接收参数是body类型请求的参数。文件类型请求形式是form-data表单形式。
        @ResponseBody
        public String body(@RequestBody ParamDTO dto,MultipartFile file){ // @RequestBody 才能支持json形式(raw类型)参数。 
            System.out.println(dto);
            if (null != file){
                System.out.println(file.getSize());
            }
            return "teemo";
        }

        @GetMapping("/header1") // Header类型请求不区分Get、Post
        @ResponseBody
        public String header1(@RequestHeader("Host") String host){
            System.out.println(host);
            return "teemo"
        }

        @GetMapping("/header2")
        @ResponseBody
        public String header2(HttpServletRequest request){
            // String host = request.getHeader("Host");
            Enumeration<String> headerNames = request.getHeaderNames();
            while (headerNames.hasMoreElements()){
                String key = headerNames.nextElement();
                String val = request.getHeader(key);
                System.out.println(key+"----"+val);
            }
            return "teemo".
        }


        @GetMapping("/path/{id}") // Path传参方式
        @ResponseBody
        public String path(@PathVariable Integer id){
            System.out.println(id);
            return "teemo"
        }

    }

    ```

- 传参方式
  - HTTP MVC中的传参方式：URL、header(包括Cookie、Session)、body 传参
  - 各种传参测试：
    - https://www.bilibili.com/video/BV1aTZYY8Eu4?spm_id_from=333.788.player.switch&vd_source=f532db78cbfe857f8de18d43caa41a3e
    1）URL传参：直接参数获取或者类获取。
    2）Body传参
    > pom.xml配置
    > 配置类函数
    ```java
    @Configuration
    @ComponentScan("com.example.mvc")
    @EnableWebMvc
    public class SpringMvcConfig implements WebMvcConfigurer {

        @Bean
        public CommonsMultipartResolver multipartResolver(){
            CommonsMultipartResolver resolver = new CommonsMultipartResolver();
            resolver.setMaxUploadsize(3000000);
            return resolver:
        }

    }
    ```
    3）Header传参
    4）Cookie、Session传参就是Header传参
    5）Path传参

- 全局异常处理
  ```java
    @ControllerAdvice // 处理全局异常
    public class GlobalExceptionHandler {
        @ExceptionHandler(RuntimeException.class) // 异常类型
        public ResponseEntity<String> handleRuntimeException(RuntimeException ex, WebRequest request){
            String message=ex.getMessage();
            return new ResponseEntity( body:"请求失败:"+message, HttpStatus.BAD_REQUEST);
        }
    }

  ```

## SSM（Spring+ SpringMvc+ Mybatis）整合
> 配置pom.xml略，大体包括：spring、servlet、jdbc、druid、lombok等库
> 想要直接maven运行需要配置：<packaging>war</packaging>

1. 配置类：
   - JdbcConfig类:DruidDataSource
        > **报错：Java.sql.SQLNonTransientConnectionException:Public Key Retrieval is not allowed**
        > 地址：jdbc:mysql://127.0.0.1:3306/userdb?useUnicode=true&characterEncoding=utf-8&useSSL=false&allowPublicKeyRetrieval=true
    - MybatisConfig类:@MapperScan+ SqlSessionFactoryBean(扫描xml配置文件，文件名称和接口同名，如UserMapper.xml，配置文件中是sql函数，然后与接口中函数可以同名，可以通过@Autowired注入接口对象并提供数据源)
    - SpringConfig类:@ComponentScan+ @EnableTransactionManagement+ @Bean+ DataSource注入和设置
    - SpringMvcConfig类：@ComponentScan+ @EnableWebMvc+ 设置文件上传接口
    - ServletConfig类：DispatcherServletInitializer实现返回SpringConfig+ SpringMvcConfig+  mapping路径

2. Controller类：@RestController+ @RequestMapping
    > 新增用户、商品服务，只需要添加：Controller+ Mapper(Mapper.xml: resources/mapper路径)+ Service(Data)


# SpringBoot框架
> 减少很多配置内容，内置tomcat服务器。
> 2.x:jdk8; 3.x:jdk17.

1. 配置：spring-boot-starter-parent、spring-boot-starter-web。
2. 配置启动类：@SpringBootApplication+ main(SpringBootApplication.run)
    > 可以直接访问默认配置的index文件，在resources/static下。
    > 在application.properties（resources目录）下配置端口等内容，“key=value”形式.缺点是层级关系不明确。
    > 
    > 在application.yml（resources目录）下配置端口等内容，如：
    > ```yml
    > server:
    >   port: 8090 // 换行需要两个空格；冒号后面必须有一个空格 
    > mybatis:
    >   mapper-locations: classpath:mapper/*.xml // 修改mybatis数据库映射文件的位置。
    > ```
3. 配置数据库、mybatis内容
    > 除了pom.xml和application.yml中内容外，还需要在Application类上标注`@MapperScan("com.example.demo.mapper")`

4. 数据驱动前端刷新的开发方式
    > Entity(@Data/@Builder等)
    > Controller(@RestController/@RequestMapping)+Service(@Resource)
    > Service(@Service)+Mapper(@Resource)
    > mybatismapper.xml中可以通过resultMap标签设置可复用的返回值字段。
5. 数据库类型处理
    > 有时候数据库存储json字符串，我想直接通过Controller得到对象，可以自定义类型处理器然后再mybatis的xml中配置。
    ```java
    public class MyIntegerListJsonTypeHandler extends BaseTypeHandler<List<Integer>> {}
    ```